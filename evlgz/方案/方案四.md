### 方案四：时间与产品代码 (`GZCPDM`) 哈希两级水平拆分，并辅以产品哈希映射表

此方案结合了按时间分片和按产品代码哈希分片的策略，形成两级分片结构。同时，引入一个单独的映射表来记录每个产品代码及其对应的哈希分片信息，以优化涉及多个特定产品的查询。

**设计思路**：

1.  **第一级分片：按时间（例如，年度或季度）**
    *   与“方案一”类似，首先将数据按 `GZDATE` 进行粗粒度的水平拆分。例如，`EVLGZ_2023`，`EVLGZ_2024_Q1` 等。
    *   每个时间分片内部的数据量仍然可能很大。

2.  **第二级分片：在每个时间分片内部，按 `GZCPDM` 哈希值（例如，10个哈希桶）**
    *   对每个时间分片（如 `EVLGZ_2023`），再将其内部的数据根据 `GZCPDM` 的哈希值进一步拆分到10个子表中。
    *   表命名可能采用如 `EVLGZ_2023_HASH_0`，`EVLGZ_2023_HASH_1`，...，`EVLGZ_2024_Q1_HASH_0` 等。
    *   哈希算法的选择和取模方式与之前讨论的纯哈希分片方案类似。

3.  **产品代码到哈希分片的映射表 (`PRODUCT_HASH_MAPPING`)**
    *   创建一个独立的表，存储 `(GZCPDM, HASH_BUCKET_ID)` 的对应关系。
    *   `HASH_BUCKET_ID` 是 `GZCPDM` 经过哈希和取模后得到的哈希桶编号（0-9）。
    *   此表在产品代码首次出现或哈希规则变更时维护。
    *   **目的**：当需要查询 `GZCPDM IN (list)` 时，可以通过关联此映射表来快速定位每个产品代码具体属于哪个哈希桶，从而避免对所有10个哈希分片进行扫描（在特定时间分片内）。

**数据结构示例**：

*   **数据表**：
    *   `EVLGZ_YYYY_HASH_B` (例如, `EVLGZ_2023_HASH_0`, `EVLGZ_2023_HASH_1`, ..., `EVLGZ_2024_Q1_HASH_9`)
        *   字段与原 `EVLGZ` 表相同。
        *   主键：`(GZCPDM, GZDATE, GZZHDM)`

*   **产品哈希映射表 (`PRODUCT_HASH_MAPPING`)**：
    *   `GZCPDM VARCHAR2(16) NOT NULL` (产品代码, 主键)
    *   `HASH_BUCKET_ID NUMBER(2) NOT NULL` (对应的哈希桶编号, 0-9)
    *   `LAST_UPDATE_TIME TIMESTAMP`

**SQL与路由逻辑示例**：

1.  **数据写入/单产品查询**：
    *   应用层首先根据 `GZDATE` 确定目标时间分片（例如，`2023`）。
    *   然后计算 `GZCPDM` 的哈希值并对10取模，得到哈希桶ID（例如，`5`）。
    *   最终定位到表 `EVLGZ_2023_HASH_5`。
    *   同时，如果 `PRODUCT_HASH_MAPPING` 表中尚无此 `GZCPDM` 的记录，则插入或更新。

2.  **查询 `GZCPDM IN (product_list)` (假设都在同一时间分片 `YYYY`)**：
    ```sql
    -- 步骤1: 从应用层传入 product_list
    -- 步骤2: 查询映射表获取每个产品对应的哈希桶
    SELECT phm.GZCPDM, phm.HASH_BUCKET_ID
    FROM PRODUCT_HASH_MAPPING phm
    WHERE phm.GZCPDM IN (:product_list);

    -- 步骤3: 应用层根据上一步结果，对每个哈希桶分别查询对应的数据表
    -- 例如，如果 product_list 中的产品分布在 HASH_0, HASH_2, HASH_5 三个桶中：
    SELECT * FROM EVLGZ_YYYY_HASH_0 WHERE GZCPDM IN (:products_for_hash_0) AND GZDATE = :target_date;
    SELECT * FROM EVLGZ_YYYY_HASH_2 WHERE GZCPDM IN (:products_for_hash_2) AND GZDATE = :target_date;
    SELECT * FROM EVLGZ_YYYY_HASH_5 WHERE GZCPDM IN (:products_for_hash_5) AND GZDATE = :target_date;

    -- 步骤4: 应用层合并结果。
    ```
    或者，如果数据库支持并且性能可接受，可以尝试更复杂的动态SQL或利用数据库特性（如某些分布式数据库的特性）来简化查询。但纯粹依赖视图 `UNION ALL` 所有哈希子表再过滤 `GZCPDM IN (list)` 性能会很差。

3.  **统一视图 (可选，用于历史数据或无法精确路由的场景)**：
    可以为每个时间分片创建一个包含其10个哈希子表的 `UNION ALL` 视图（如 `EVLGZ_2023_VIEW`），然后再将这些时间视图 `UNION ALL` 起来形成一个总视图（如 `EVLGZ_TOTAL_VIEW`）。但这主要用于兼容旧的、无法改造的查询，性能通常不佳。

**优势**：
-   **有效控制单表大小**：通过时间和哈希两级分片，可以将巨大的数据量分解到更小的、可管理的单元中。
-   **提升单产品查询性能**：当 `GZDATE` 和 `GZCPDM` 都提供时，可以精确定位到单个非常小的表。
-   **优化 `GZCPDM IN (list)` 查询**：通过 `PRODUCT_HASH_MAPPING` 表，可以避免在特定时间分片内扫描所有10个哈希子表，而是只查询包含目标产品的哈希子表。
-   **数据分布相对均匀**：哈希有助于在每个时间分片的二级分片中实现较均匀的数据分布。
-   **与数据库无关**：核心逻辑在应用层，不依赖特定数据库的高级分区功能。

**缺点**：
-   **复杂度显著增加**：两级分片引入了更复杂的表管理、数据路由和查询逻辑。
-   **`PRODUCT_HASH_MAPPING` 表的维护**：需要确保此映射表的准确性和实时性。其自身也可能成为瓶颈或单点，尽管其数据量远小于主数据表。
-   **数据倾斜风险依然存在**：虽然哈希有助于均匀分布，但如果某些 `GZCPDM` 的数据量本身就极大，即使它们被路由到独立的哈希桶，该桶对应的数据表（在特定时间分片内）仍然可能很大。10个哈希桶对于非常集中的热点产品可能不足。
-   **跨时间分片的 `GZCPDM IN (list)` 查询**：如果查询的 `product_list` 中的数据分布在不同的时间分片，则需要在每个相关的时间分片内都执行上述的哈希子表定位和查询逻辑，然后合并结果，复杂度更高。
-   **应用层改造工作量大**：需要对数据访问层进行较大规模的重构以支持两级路由和映射表的使用。
-   **事务管理**：跨多个分片的事务（如果需要）会变得非常复杂。

**实施步骤**：
1.  **详细设计与验证**：
    *   确定时间分片的粒度（年/季/月）。
    *   选择并测试哈希算法，确定哈希桶数量（这里是10）。
    *   设计 `PRODUCT_HASH_MAPPING` 表的更新和维护策略。
    *   原型验证查询路由逻辑和性能。
2.  **表结构创建**：
    *   创建所有时间分片下的哈希子表。
    *   创建 `PRODUCT_HASH_MAPPING` 表。
3.  **数据迁移策略**：
    *   这是一个复杂的过程，需要先按时间迁移，然后在每个时间分片内按哈希迁移。
    *   同时需要填充 `PRODUCT_HASH_MAPPING` 表。
4.  **应用层改造**：
    *   实现两级路由逻辑（时间路由 + 哈希路由）。
    *   实现与 `PRODUCT_HASH_MAPPING` 表的交互逻辑。
    *   改造所有相关的读写操作。
5.  **视图创建 (可选)**：根据需要创建各级视图。
6.  **测试与上线**：进行更全面的测试，覆盖各种查询场景。
7.  **监控与优化**：持续监控所有层级的表性能、数据分布和映射表的健康状况。
